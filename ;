use crate::lexer::Token;

struct Number {
    positive: bool,
    contens: f64,
}

pub enum CalcType<'a> {
    Num(Number),
    Plus,
    Minus,
    Mul,
    Div,
    Group(Box<Calc<'a>>), // Box is for the non-infinite size
}

impl<'a> CalcType<'a> {
    pub fn solve(&self) -> Option<Number> {
        match self {
            CalcType::Group(brkt) => {
                return Some(brkt.solve());
            }
            _ => {
                return None;
            }
        }
    }
}

pub struct Calc<'a> {
    calctype: CalcType<'a>,
    num1: &'a Number,
    num2: &'a Number,
    // I'm not gonna make copies of the numbers, just references
}

impl<'a> Calc<'a> {
    pub fn new(calctype: CalcType<'a>, num1: &'a Number, num2: &'a Number) -> Self {
        Self {
            calctype: calctype,
            num1: num1,
            num2: num2,
        }
    }

    pub fn solve(&self) -> Number {
        match &self.calctype {
            CalcType::Plus => Number {
                positive: if self.num1.positive == self.num2.positive {
                    true
                } else {
                    false
                },
                contens: self.num1.contens + self.num2.contens,
            },
            CalcType::Minus => Number {
                positive: if self.num1.positive == self.num2.positive {
                    true
                } else {
                    false
                },
                contens: self.num1.contens - self.num2.contens,
            },
            CalcType::Mul => Number {
                positive: if self.num1.positive == self.num2.positive {
                    true
                } else {
                    false
                },
                contens: self.num1.contens * self.num2.contens,
            },
            CalcType::Div => Number {
                positive: if self.num1.positive == self.num2.positive {
                    true
                } else {
                    false
                },
                contens: self.num1.contens / self.num2.contens,
            },
            _ => Number {
                positive: if self.num1.positive == self.num2.positive {
                    true
                } else {
                    false
                },
                contens: 0 as f64,
            },
        }
    }
}

pub enum Eqt<'a> {
    Calc(Calc<'a>),
    Brkt(Vec<Calc<'a>>),
}

pub struct Parser<'a> {
    toks: Vec<Token>,
    equt: Vec<Eqt<'a>>,
}

impl<'a> Parser<'a> {
    pub fn from_toks(toks: Vec<Token>) -> Self {
        Self {
            toks: toks,
            equt: Vec::<Calc>::new(),
        }
    }

    pub fn solve(&mut self) -> f64 {
        for i in 0..self.equt.len() {
            let eq = &self.equt[i];
            match &eq.calctype {
                CalcType::Group(brkt) => {
                    self.equt[i] = brkt.solve();
                }
                _ => {}
            }
        }
        return 0 as f64;
    }
}
